/**
 * Jogo da Velha Bin√°rio - Sistema Principal
 * 
 * Um jogo da velha moderno com tema de programa√ß√£o onde os jogadores
 * usam os s√≠mbolos 0 e 1, criando um trocadilho divertido com o mundo
 * da programa√ß√£o e sistemas bin√°rios.
 * 
 * Arquitetura: Modular e orientada a objetos para f√°cil manuten√ß√£o
 */

import { BinaryGameBoard } from './modules/binaryGameBoard.js';
import { BinaryGameLogic } from './modules/binaryGameLogic.js';
import { BinaryUIController } from './modules/binaryUIController.js';
import { BinaryAIPlayer } from './modules/binaryAIPlayer.js';

/**
 * Classe principal que orquestra o Jogo da Velha Bin√°rio
 * Gerencia o estado global e coordena todos os m√≥dulos
 */
class BinaryTicTacToe {
    constructor() {
        // Inicializa√ß√£o dos m√≥dulos especializados
        this.gameBoard = new BinaryGameBoard();
        this.gameLogic = new BinaryGameLogic();
        this.uiController = new BinaryUIController();
        this.aiPlayer = new BinaryAIPlayer();
        
        // Estado central do jogo
        this.gameState = {
            isGameActive: false,
            currentMode: null, // 'two-players' ou 'ai-player'
            currentPlayer: '1', // Jogador 1 sempre come√ßa (como true em programa√ß√£o)
            isAIProcessing: false,
            sessionStats: { 
                '1': 0, 
                '0': 0,
                totalGames: 0,
                draws: 0
            }
        };
        
        // Bind de m√©todos para preservar contexto
        this.handleCellClick = this.handleCellClick.bind(this);
        this.handleModeSelection = this.handleModeSelection.bind(this);
        this.handleNewGame = this.handleNewGame.bind(this);
        this.handleBackToMenu = this.handleBackToMenu.bind(this);
        
        this.initializeApplication();
    }
    
    /**
     * Inicializa toda a aplica√ß√£o configurando eventos e interface
     */
    initializeApplication() {
        console.log('üöÄ Inicializando Jogo da Velha Bin√°rio...');
        
        // Configurar todos os event listeners
        this.setupModeSelection();
        this.setupGameControls();
        this.setupResultModal();
        this.setupKeyboardControls();
        this.setupAccessibilityFeatures();
        
        // Mostrar mensagem de boas-vindas
        this.uiController.showWelcomeMessage();
        
        console.log('‚úÖ Aplica√ß√£o inicializada com sucesso!');
    }
    
    /**
     * Configura os controles de sele√ß√£o de modo
     */
    setupModeSelection() {
        const twoPlayersBtn = document.getElementById('two-players-btn');
        const aiPlayerBtn = document.getElementById('ai-player-btn');
        
        twoPlayersBtn.addEventListener('click', () => {
            this.handleModeSelection('two-players');
        });
        
        aiPlayerBtn.addEventListener('click', () => {
            this.handleModeSelection('ai-player');
        });
    }
    
    /**
     * Configura controles principais do jogo
     */
    setupGameControls() {
        const newGameBtn = document.getElementById('new-game-btn');
        const changeModeBtn = document.getElementById('change-mode-btn');
        
        newGameBtn.addEventListener('click', this.handleNewGame);
        changeModeBtn.addEventListener('click', this.handleBackToMenu);
    }
    
    /**
     * Configura controles do modal de resultado
     */
    setupResultModal() {
        const playAgainBtn = document.getElementById('play-again-btn');
        const backToMenuBtn = document.getElementById('back-to-menu-btn');
        
        playAgainBtn.addEventListener('click', this.handleNewGame);
        backToMenuBtn.addEventListener('click', this.handleBackToMenu);
    }
    
    /**
     * Implementa controles por teclado para acessibilidade
     */
    setupKeyboardControls() {
        document.addEventListener('keydown', (event) => {
            // Navega√ß√£o num√©rica no tabuleiro (1-9)
            if (this.gameState.isGameActive && !this.gameState.isAIProcessing) {
                const key = parseInt(event.key);
                if (key >= 1 && key <= 9) {
                    const cellIndex = key - 1;
                    const cell = this.gameBoard.getCell(cellIndex);
                    if (cell && !cell.classList.contains('occupied')) {
                        this.handleCellClick({ target: cell });
                    }
                }
            }
            
            // Atalhos de controle
            switch(event.key.toLowerCase()) {
                case 'n':
                    if (this.gameState.isGameActive) {
                        this.handleNewGame();
                    }
                    break;
                case 'escape':
                    this.uiController.hideResultModal();
                    break;
                case 'm':
                    if (this.gameState.isGameActive) {
                        this.handleBackToMenu();
                    }
                    break;
            }
        });
    }
    
    /**
     * Configura recursos de acessibilidade avan√ßados
     */
    setupAccessibilityFeatures() {
        // Anunciar mudan√ßas importantes para leitores de tela
        this.uiController.setupScreenReaderAnnouncements();
        
        // Configurar indicadores visuais para usu√°rios com defici√™ncia auditiva
        this.uiController.setupVisualFeedback();
    }
    
    /**
     * Gerencia a sele√ß√£o do modo de jogo
     */
    handleModeSelection(mode) {
        console.log(`üéØ Modo selecionado: ${mode}`);
        
        this.gameState.currentMode = mode;
        this.gameState.isGameActive = true;
        this.gameState.currentPlayer = '1'; // 1 sempre come√ßa (como true)
        
        // Transi√ß√£o visual suave
        this.uiController.showGameBoard();
        this.uiController.updateCurrentPlayerIndicator(this.gameState.currentPlayer);
        this.uiController.applyModeTheme(mode);
        
        // Inicializar tabuleiro
        this.gameBoard.initialize(this.handleCellClick);
        
        // Feedback para o usu√°rio
        const modeText = mode === 'two-players' ? 'Modo Duplo' : 'Vs Algoritmo';
        this.uiController.showNotification(`${modeText} ativado!`, 'success');
    }
    
    /**
     * Processa cliques nas c√©lulas do tabuleiro
     */
    async handleCellClick(event) {
        const cell = event.target;
        const cellIndex = parseInt(cell.dataset.index);
        
        // Valida√ß√µes de seguran√ßa
        if (!this.gameState.isGameActive || 
            cell.classList.contains('occupied') || 
            this.gameState.isAIProcessing) {
            return;
        }
        
        console.log(`üíæ Bit ${this.gameState.currentPlayer} gravado na posi√ß√£o [${cellIndex}]`);
        
        // Executar jogada
        this.gameBoard.makeMove(cellIndex, this.gameState.currentPlayer);
        
        // Verificar condi√ß√µes de fim de jogo
        const gameResult = this.gameLogic.checkGameEnd(this.gameBoard.getBoardState());
        
        if (gameResult.isGameOver) {
            this.handleGameEnd(gameResult);
            return;
        }
        
        // Alternar jogador
        this.switchPlayer();
        
        // Processar turno da IA se necess√°rio
        if (this.gameState.currentMode === 'ai-player' && this.gameState.currentPlayer === '0') {
            await this.handleAITurn();
        }
    }
    
    /**
     * Gerencia o turno da IA com feedback visual
     */
    async handleAITurn() {
        this.gameState.isAIProcessing = true;
        
        // Feedback visual de processamento
        this.uiController.showAIProcessing(true);
        
        // Simular tempo de processamento para melhor UX
        await new Promise(resolve => setTimeout(resolve, 1200));
        
        // IA calcula e executa jogada
        const aiMove = this.aiPlayer.calculateBestMove(this.gameBoard.getBoardState());
        
        if (aiMove !== -1) {
            this.gameBoard.makeMove(aiMove, '0');
            
            // Verificar resultado ap√≥s jogada da IA
            const gameResult = this.gameLogic.checkGameEnd(this.gameBoard.getBoardState());
            
            if (gameResult.isGameOver) {
                this.handleGameEnd(gameResult);
            } else {
                this.switchPlayer();
            }
        }
        
        this.gameState.isAIProcessing = false;
        this.uiController.showAIProcessing(false);
    }
    
    /**
     * Alterna entre jogadores e atualiza interface
     */
    switchPlayer() {
        this.gameState.currentPlayer = this.gameState.currentPlayer === '1' ? '0' : '1';
        this.uiController.updateCurrentPlayerIndicator(this.gameState.currentPlayer);
        
        // Anunciar mudan√ßa para acessibilidade
        const playerName = this.gameState.currentPlayer === '1' ? 'um' : 'zero';
        this.uiController.announceToScreenReader(`Vez do jogador ${playerName}`);
    }
    
    /**
     * Processa o fim do jogo e atualiza estat√≠sticas
     */
    handleGameEnd(gameResult) {
        console.log('üèÅ Fim de execu√ß√£o:', gameResult);
        
        this.gameState.isGameActive = false;
        this.gameState.totalGames++;
        
        // Destacar sequ√™ncia vencedora
        if (gameResult.winningCombination) {
            this.gameBoard.highlightWinningSequence(gameResult.winningCombination);
        }
        
        // Atualizar estat√≠sticas da sess√£o
        this.updateSessionStats(gameResult);
        
        // Mostrar resultado com delay para visualiza√ß√£o
        setTimeout(() => {
            this.uiController.showGameResult(gameResult, this.gameState.currentMode);
        }, 1200);
    }
    
    /**
     * Atualiza estat√≠sticas da sess√£o atual
     */
    updateSessionStats(gameResult) {
        if (gameResult.winner === 'draw') {
            this.gameState.sessionStats.draws++;
        } else if (gameResult.winner) {
            this.gameState.sessionStats[gameResult.winner]++;
        }
        
        this.gameState.sessionStats.totalGames++;
        this.uiController.updateScoreboard(this.gameState.sessionStats);
        
        console.log('üìä Estat√≠sticas atualizadas:', this.gameState.sessionStats);
    }
    
    /**
     * Inicia nova partida mantendo modo e estat√≠sticas
     */
    handleNewGame() {
        console.log('üîÑ Reinicializando sistema...');
        
        this.gameBoard.reset();
        this.gameState.isGameActive = true;
        this.gameState.currentPlayer = '1'; // 1 sempre inicia
        this.gameState.isAIProcessing = false;
        
        this.uiController.hideResultModal();
        this.uiController.updateCurrentPlayerIndicator(this.gameState.currentPlayer);
        
        this.uiController.showNotification('Sistema reinicializado!', 'info');
    }
    
    /**
     * Retorna ao menu principal resetando tudo
     */
    handleBackToMenu() {
        console.log('üè† Retornando ao menu principal...');
        
        // Reset completo do estado
        this.gameBoard.reset();
        this.gameState = {
            isGameActive: false,
            currentMode: null,
            currentPlayer: '1',
            isAIProcessing: false,
            sessionStats: { 
                '1': 0, 
                '0': 0,
                totalGames: 0,
                draws: 0
            }
        };
        
        // Voltar para sele√ß√£o de modo
        this.uiController.showModeSelection();
        this.uiController.hideResultModal();
        this.uiController.updateScoreboard(this.gameState.sessionStats);
        
        this.uiController.showNotification('Voltando ao menu...', 'info');
    }
    
    /**
     * Retorna estat√≠sticas detalhadas da sess√£o
     */
    getSessionStats() {
        return {
            ...this.gameState.sessionStats,
            winRate: {
                '1': this.gameState.sessionStats.totalGames > 0 
                    ? (this.gameState.sessionStats['1'] / this.gameState.sessionStats.totalGames * 100).toFixed(1)
                    : 0,
                '0': this.gameState.sessionStats.totalGames > 0 
                    ? (this.gameState.sessionStats['0'] / this.gameState.sessionStats.totalGames * 100).toFixed(1)
                    : 0
            }
        };
    }
}

// Inicializa√ß√£o quando DOM estiver pronto
document.addEventListener('DOMContentLoaded', () => {
    console.log('üîå DOM carregado, inicializando aplica√ß√£o bin√°ria...');
    
    // Criar inst√¢ncia global do jogo
    window.binaryTicTacToe = new BinaryTicTacToe();
    
    // Easter egg: log bin√°rio no console
    console.log(`
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë  01001010 JOGO DA VELHA 01010101     ‚ïë
    ‚ïë  Sistema inicializado com sucesso!   ‚ïë
    ‚ïë  Vers√£o: 1.0.0 | Build: ${Date.now().toString(2).slice(-8)} ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    `);
});

// Adicionar alguns easter eggs para desenvolvedores
window.getBinaryStats = () => {
    if (window.binaryTicTacToe) {
        return window.binaryTicTacToe.getSessionStats();
    }
    return null;
};

window.toggleDebugMode = () => {
    document.body.classList.toggle('debug-mode');
    console.log('üêõ Modo debug alternado');
};